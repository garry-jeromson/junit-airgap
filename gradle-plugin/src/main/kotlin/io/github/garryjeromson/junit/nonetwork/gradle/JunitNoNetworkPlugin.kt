package io.github.garryjeromson.junit.nonetwork.gradle

import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.tasks.testing.Test
import org.gradle.kotlin.dsl.create
import org.gradle.kotlin.dsl.withType
import java.io.File

/**
 * Gradle plugin that automatically configures JUnit tests to block network requests.
 *
 * This plugin:
 * - Adds the junit-no-network library dependency to test configurations
 * - Creates junit-platform.properties for JUnit 5 automatic extension discovery
 * - Configures Test tasks with appropriate system properties
 * - Supports JVM, Android, and Kotlin Multiplatform projects
 *
 * Usage:
 * ```kotlin
 * plugins {
 *     id("io.github.garryjeromson.junit-no-network") version "0.1.0"
 * }
 *
 * junitNoNetwork {
 *     enabled = true
 *     applyToAllTests = true
 * }
 * ```
 */
class JunitNoNetworkPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        // Create extension
        val extension = project.extensions.create<JunitNoNetworkExtension>("junitNoNetwork")

        // Configure after project evaluation
        project.afterEvaluate {
            if (!extension.enabled.get()) {
                project.logger.info("JUnit No-Network plugin is disabled")
                return@afterEvaluate
            }

            configureProject(project, extension)
        }
    }

    private fun configureProject(
        project: Project,
        extension: JunitNoNetworkExtension,
    ) {
        project.logger.lifecycle("Configuring JUnit No-Network plugin")

        // 1. Add library dependency
        addDependencies(project, extension)

        // 2. Configure Test tasks (system properties work for all project types)
        configureTestTasks(project, extension)

        // 3. Configure JUnit 4 rule injection (if enabled)
        if (extension.injectJUnit4Rule.get()) {
            configureJUnit4RuleInjection(project, extension)
        }

        // 4. Handle Kotlin Multiplatform projects
        if (project.plugins.hasPlugin("org.jetbrains.kotlin.multiplatform")) {
            configureKmpProject(project, extension)
        } else {
            // 5. For non-KMP projects, configure JUnit Platform properties
            configureJunitPlatform(project, extension)
        }
    }

    private fun addDependencies(
        project: Project,
        extension: JunitNoNetworkExtension,
    ) {
        val version = extension.libraryVersion.get()

        // Determine which configurations to add the dependency to
        val configurations =
            when {
                project.plugins.hasPlugin("org.jetbrains.kotlin.multiplatform") -> {
                    // KMP project - dependencies are handled per source set
                    project.logger.info("Detected KMP project, dependencies will be added per source set")
                    emptyList()
                }

                project.plugins.hasPlugin("com.android.library") ||
                    project.plugins.hasPlugin("com.android.application") -> {
                    // Android project
                    listOf("testImplementation")
                }

                else -> {
                    // Regular JVM project
                    listOf("testImplementation")
                }
            }

        configurations.forEach { configName ->
            project.configurations.findByName(configName)?.let { _ ->
                project.dependencies.add(
                    configName,
                    "io.github.garryjeromson:junit-no-network:$version",
                )
                project.logger.info("Added junit-no-network:$version to $configName")
            }
        }
    }

    private fun configureJunitPlatform(
        project: Project,
        extension: JunitNoNetworkExtension,
    ) {
        // Generate junit-platform.properties in build directory (not src/)
        val generatedResourcesDir =
            project.layout.buildDirectory
                .dir(
                    "generated/junit-platform/test/resources",
                ).get()
                .asFile
        val propsFile = File(generatedResourcesDir, "junit-platform.properties")

        // Create directory if it doesn't exist
        generatedResourcesDir.mkdirs()

        // Generate properties content
        val properties =
            buildString {
                appendLine("# Generated by JUnit No-Network Gradle Plugin")
                appendLine("# Enable JUnit 5 automatic extension discovery")
                appendLine("junit.jupiter.extensions.autodetection.enabled=true")
                appendLine()
                appendLine("# Network blocking configuration")
                appendLine("junit.nonetwork.applyToAllTests=${extension.applyToAllTests.get()}")

                if (extension.debug.get()) {
                    appendLine("junit.nonetwork.debug=true")
                }
            }

        // Write properties file
        propsFile.writeText(properties)
        project.logger.lifecycle("Generated junit-platform.properties at: ${propsFile.absolutePath}")

        // Add generated resources to test source set
        addGeneratedResourcesToSourceSet(project, generatedResourcesDir, "test")
    }

    private fun addGeneratedResourcesToSourceSet(
        project: Project,
        resourcesDir: File,
        sourceSetName: String,
    ) {
        try {
            // Access source sets using reflection to avoid compile-time dependency
            val sourceSets = project.extensions.findByName("sourceSets")
            if (sourceSets != null) {
                val getByName = sourceSets.javaClass.getMethod("getByName", String::class.java)
                val sourceSet = getByName.invoke(sourceSets, sourceSetName)
                val resources = sourceSet.javaClass.getMethod("getResources").invoke(sourceSet)
                val srcDir = resources.javaClass.getMethod("srcDir", Any::class.java)
                srcDir.invoke(resources, resourcesDir)
                project.logger.info("Added generated resources to $sourceSetName source set")
            }
        } catch (e: Exception) {
            // Source sets might not exist in all project types - that's okay, system properties will still work
            project.logger.debug("Could not add generated resources to source set: ${e.message}")
        }
    }

    private fun configureTestTasks(
        project: Project,
        extension: JunitNoNetworkExtension,
    ) {
        project.tasks.withType<Test>().configureEach {
            // Configure system properties for the test JVM
            systemProperty("junit.jupiter.extensions.autodetection.enabled", "true")
            systemProperty("junit.nonetwork.applyToAllTests", extension.applyToAllTests.get())

            // Enable SecurityManager on Java 21+ (required for SECURITY_MANAGER and SECURITY_POLICY implementations)
            // On Java 21+, SecurityManager is deprecated and disabled by default
            // This JVM argument allows setting it: https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/SecurityManager.html
            jvmArgs("-Djava.security.manager=allow")

            if (extension.debug.get()) {
                systemProperty("junit.nonetwork.debug", "true")
            }

            project.logger.info("Configured test task: $name with network blocking")
        }
    }

    private fun configureKmpProject(
        project: Project,
        extension: JunitNoNetworkExtension,
    ) {
        val version = extension.libraryVersion.get()

        project.logger.info("Configuring KMP project for JUnit No-Network")

        // For KMP projects, add dependencies using platform-specific configuration names
        // These configurations are created by the Kotlin Multiplatform plugin
        val kmpTestConfigurations =
            listOf(
                "jvmTestImplementation",
                "androidUnitTestImplementation",
            )

        kmpTestConfigurations.forEach { configName ->
            project.configurations.findByName(configName)?.let { _ ->
                try {
                    project.dependencies.add(
                        configName,
                        "io.github.garryjeromson:junit-no-network:$version",
                    )
                    project.logger.info("Added junit-no-network:$version to $configName")
                } catch (e: Exception) {
                    project.logger.debug("Failed to add dependency to $configName: ${e.message}")
                }
            } ?: project.logger.debug("Configuration $configName not found")
        }

        // Note: We don't generate junit-platform.properties files for KMP projects
        // because system properties configured on Test tasks are sufficient and
        // avoid duplicate resource issues
        project.logger.info("Configuration complete - using system properties for KMP test configuration")
    }

    private fun createJunitPlatformProperties(
        project: Project,
        sourceSetName: String,
        extension: JunitNoNetworkExtension,
    ) {
        // Generate in build directory, not src/
        val generatedResourcesDir =
            project.layout.buildDirectory
                .dir(
                    "generated/junit-platform/$sourceSetName/resources",
                ).get()
                .asFile
        val propsFile = File(generatedResourcesDir, "junit-platform.properties")

        generatedResourcesDir.mkdirs()

        val properties =
            buildString {
                appendLine("# Generated by JUnit No-Network Gradle Plugin")
                appendLine("junit.jupiter.extensions.autodetection.enabled=true")
                appendLine("junit.nonetwork.applyToAllTests=${extension.applyToAllTests.get()}")
            }

        propsFile.writeText(properties)
        project.logger.lifecycle("Generated junit-platform.properties for $sourceSetName at: ${propsFile.absolutePath}")

        // Add generated resources to the KMP source set
        addGeneratedResourcesToKmpSourceSet(project, generatedResourcesDir, sourceSetName)
    }

    private fun addGeneratedResourcesToKmpSourceSet(
        project: Project,
        resourcesDir: File,
        sourceSetName: String,
    ) {
        try {
            val kotlin = project.extensions.findByName("kotlin") ?: return
            val sourceSets = kotlin.javaClass.getMethod("getSourceSets").invoke(kotlin)
            val getByName = sourceSets.javaClass.getMethod("getByName", String::class.java)
            val sourceSet = getByName.invoke(sourceSets, sourceSetName)
            val resources = sourceSet.javaClass.getMethod("getResources").invoke(sourceSet)
            val srcDir = resources.javaClass.getMethod("srcDir", Any::class.java)
            srcDir.invoke(resources, resourcesDir)
            project.logger.info("Added generated resources to $sourceSetName KMP source set")
        } catch (e: Exception) {
            project.logger.debug("Could not add generated resources to KMP source set $sourceSetName: ${e.message}")
        }
    }

    private fun configureJUnit4RuleInjection(
        project: Project,
        extension: JunitNoNetworkExtension,
    ) {
        project.logger.lifecycle("Configuring JUnit 4 @Rule injection via bytecode enhancement")

        // Detect project type and configure accordingly
        val hasKmpPlugin = project.plugins.hasPlugin("org.jetbrains.kotlin.multiplatform")
        val hasAndroidLibrary = project.plugins.hasPlugin("com.android.library")
        val hasAndroidApp = project.plugins.hasPlugin("com.android.application")

        project.logger.lifecycle(
            "Plugin detection: KMP=$hasKmpPlugin, AndroidLib=$hasAndroidLibrary, AndroidApp=$hasAndroidApp",
        )

        when {
            hasKmpPlugin -> {
                project.logger.lifecycle("Detected KMP project - configuring KMP injection")
                configureKmpJUnit4Injection(project, extension)
            }
            hasAndroidLibrary || hasAndroidApp -> {
                project.logger.lifecycle("Detected Android project - configuring Android injection")
                configureAndroidJUnit4Injection(project, extension)
            }
            else -> {
                project.logger.lifecycle("Detected JVM project - configuring JVM injection")
                configureJvmJUnit4Injection(project, extension)
            }
        }
    }

    private fun configureJvmJUnit4Injection(
        project: Project,
        extension: JunitNoNetworkExtension,
    ) {
        // Register injection task for JVM project
        val injectionTask =
            project.tasks.register("injectJUnit4NetworkRule", JUnit4RuleInjectionTask::class.java) {
                testClassesDir.set(project.layout.buildDirectory.dir("classes/kotlin/test"))
                debug.set(extension.debug)
                testTaskName.set("test")
            }

        // Hook after test compilation
        project.tasks.matching { it.name == "compileTestKotlin" || it.name == "compileTestJava" }.all {
            finalizedBy("injectJUnit4NetworkRule")
        }

        // Ensure test task depends on injection
        project.tasks.matching { it.name == "test" }.all {
            dependsOn("injectJUnit4NetworkRule")
        }

        project.logger.info("Configured JUnit 4 rule injection for JVM project")
    }

    private fun configureAndroidJUnit4Injection(
        project: Project,
        extension: JunitNoNetworkExtension,
    ) {
        // Register injection task for Android unit tests
        val injectionTask =
            project.tasks.register("injectJUnit4NetworkRule", JUnit4RuleInjectionTask::class.java) {
                // Use Kotlin classes directory - this includes both androidUnitTest and commonTest classes
                testClassesDir.set(project.layout.buildDirectory.dir("tmp/kotlin-classes/debugUnitTest"))
                debug.set(extension.debug)
                testTaskName.set("testDebugUnitTest")
            }

        // Hook after Android test compilation
        project.tasks
            .matching {
                it.name.contains("compileDebugUnitTestKotlin") || it.name.contains("compileDebugUnitTestJava")
            }.all {
                finalizedBy("injectJUnit4NetworkRule")
            }

        // Ensure test task depends on injection
        project.tasks.matching { it.name.contains("testDebugUnitTest") }.all {
            dependsOn("injectJUnit4NetworkRule")
        }

        project.logger.info("Configured JUnit 4 rule injection for Android project")
    }

    private fun configureKmpJUnit4Injection(
        project: Project,
        extension: JunitNoNetworkExtension,
    ) {
        // For KMP, we need to configure injection for each target platform
        // JVM target
        project.tasks.register("injectJvmJUnit4NetworkRule", JUnit4RuleInjectionTask::class.java) {
            testClassesDir.set(project.layout.buildDirectory.dir("classes/kotlin/jvm/test"))
            debug.set(extension.debug)
            testTaskName.set("jvmTest")

            // Depend on compilation task
            project.tasks.findByName("compileTestKotlinJvm")?.let { compileTask ->
                mustRunAfter(compileTask)
                dependsOn(compileTask)
            }
        }

        // Android target
        project.tasks.register("injectAndroidJUnit4NetworkRule", JUnit4RuleInjectionTask::class.java) {
            // Use Kotlin classes directory - this includes both androidUnitTest and commonTest classes
            testClassesDir.set(project.layout.buildDirectory.dir("tmp/kotlin-classes/debugUnitTest"))
            debug.set(extension.debug)
            testTaskName.set("testDebugUnitTest")

            // Depend on compilation task
            project.tasks.findByName("compileDebugUnitTestKotlinAndroid")?.let { compileTask ->
                mustRunAfter(compileTask)
                dependsOn(compileTask)
            }
        }

        project.logger.info("Configured JUnit 4 rule injection for KMP project (manual execution: run injection tasks then test tasks)")
    }
}
